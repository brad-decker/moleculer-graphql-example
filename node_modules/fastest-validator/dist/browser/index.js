(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.FastestValidator = factory());
}(this, (function () { 'use strict';

"use strict";

/**
 * Flatten an array
 * @param {Array} array
 * @param {Array} target
 * @returns Array flattened array
 */
function flatten(array, target) {
	var result = target || [];

	for (var i = 0; i < array.length; ++i) {
		if (Array.isArray(array[i])) {
			flatten(array[i], result);
		}
		else {
			result.push(array[i]);
		}
	}

	return result;
}

var flatten_1 = flatten;

"use strict";

function deepExtend(destination, source) {
	for (var property in source) {
		if (typeof source[property] === "object" &&
			source[property] !== null) {
			destination[property] = destination[property] || {};
			deepExtend(destination[property], source[property]);
		} else {
			destination[property] = source[property];
		}
	}
	return destination;
}

var deepExtend_1 = deepExtend;

"use strict";

var messages = {
	required: "The '{field}' field is required!",

	string: "The '{field}' field must be a string!",
	stringEmpty: "The '{field}' field must not be empty!",
	stringMin: "The '{field}' field length must be larger than or equal to {expected} characters long!",
	stringMax: "The '{field}' field length must be less than or equal to {expected} characters long!",
	stringLength: "The '{field}' field length must be {expected} characters long!",
	stringPattern: "The '{field}' field fails to match the required pattern!",
	stringContains: "The '{field}' field must contain the '{expected}' text!",
	stringEnum: "The '{field}' field does not match any of the allowed values!",

	number: "The '{field}' field must be a number!",
	numberMin: "The '{field}' field must be larger than or equal to {expected}!",
	numberMax: "The '{field}' field must be less than or equal to {expected}!",
	numberEqual: "The '{field}' field must be equal with {expected}!",
	numberNotEqual: "The '{field}' field can't be equal with {expected}!",
	numberInteger: "The '{field}' field must be an integer!",
	numberPositive: "The '{field}' field must be a positive number!",
	numberNegative: "The '{field}' field must be a negative number!",
	
	array: "The '{field}' field must be an array!",
	arrayEmpty: "The '{field}' field must not be an empty array!",
	arrayMin: "The '{field}' field must contain at least {expected} items!",
	arrayMax: "The '{field}' field must contain less than or equal to {expected} items!",
	arrayLength: "The '{field}' field must contain {expected} items!",
	arrayContains: "The '{field}' field must contain the '{expected}' item!",
	arrayEnum: "The '{field} field value '{expected}' does not match any of the allowed values!",

	boolean: "The '{field}' field must be a boolean!",

	function: "The '{field}' field must be a function!",

	date: "The '{field}' field must be a Date!",
	dateMin: "The '{field}' field must be larger than or equal to {expected}!",
	dateMax: "The '{field}' field must be less than or equal to {expected}!",

	forbidden: "The '{field}' field is forbidden!",
	
	email: "The '{field}' field must be a valid e-mail!"
};

"use strict";

var any = function checkAny() {
	return true;
};

"use strict";

var array = function checkArray(value, schema) {
	var this$1 = this;

	if (!Array.isArray(value)) {
		return this.makeError("array");
	}

	var arrLength = value.length;

	if (schema.empty === false && arrLength === 0) {
		return this.makeError("arrayEmpty");
	}

	if (schema.min != null && arrLength < schema.min) {
		return this.makeError("arrayMin", schema.min, arrLength);
	}

	if (schema.max != null && arrLength > schema.max) {
		return this.makeError("arrayMax", schema.max, arrLength);
	}

	// Check fix length
	if (schema.length != null && arrLength !== schema.length) {
		return this.makeError("arrayLength", schema.length, arrLength);
	}	

	if (schema.contains != null && value.indexOf(schema.contains) === -1) {
		return this.makeError("arrayContains", schema.contains);
	}	

	if (schema.enum != null) {
		for (var i = 0; i < value.length; i++) {
			if (schema.enum.indexOf(value[i]) === -1) {
				return this$1.makeError("arrayEnum", value[i], schema.enum);
			}
		}
	}	

	return true;
};

"use strict";

var boolean_1 = function checkBoolean(value, schema) {
	if (schema.convert === true && typeof value !== "boolean") {
		if (
			value === 1
		|| value === 0
		|| value === "true"
		|| value === "false"
		|| value === "1"
		|| value === "0"
		|| value === "on"
		|| value === "off"
		) 
			{ return true; }
	}
	
	if (typeof value !== "boolean") {
		return this.makeError("boolean");
	}

	return true;
};

"use strict";

var custom = function customCheck(value, schema) {
	return schema.check.call(this, value, schema);
};

"use strict";

var date = function checkDate(value, schema) {
	if (schema.convert === true && !(value instanceof Date)) {
		value = new Date(value);
	}
	
	if (!(value instanceof Date)) {
		return this.makeError("date");
	}

	if (isNaN(value.getTime())) {
		return this.makeError("date");
	}

	return true;
};

"use strict";

var PRECISE_PATTERN = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var BASIC_PATTERN = /^\S+@\S+\.\S+$/;

var email = function checkEmail(value, schema) {
	if (typeof value !== "string") {
		return this.makeError("string");
	}

	var pattern;
	if (schema.mode == "precise")
		{ pattern = PRECISE_PATTERN; }
	else
		{ pattern = BASIC_PATTERN; }
	
	if (!pattern.test(value)) {
		return this.makeError("email");
	}

	return true;
};

"use strict";

var forbidden = function checkForbidden(value) {
	if (value !== null && value !== undefined) {
		return this.makeError("forbidden");
	}

	return true;
};

"use strict";

var _function = function checkFunction(value) {
	if (typeof value !== "function") {
		return this.makeError("function");
	}

	return true;
};

"use strict";

var number = function checkNumber(value, schema) {
	if (schema.convert === true && typeof value !== "number") {
		value = Number(value);
	}

	if (typeof value !== "number") {
		return this.makeError("number");
	}

	if (isNaN(value) || !isFinite(value)) {
		return this.makeError("number");
	}

	if (schema.min != null && value < schema.min) {
		return this.makeError("numberMin", schema.min, value);
	}

	if (schema.max != null && value > schema.max) {
		return this.makeError("numberMax", schema.max, value);
	}

	// Check fix value
	if (schema.equal != null && value !== schema.equal) {
		return this.makeError("numberEqual", schema.equal, value);
	}	

	// Check not fix value
	if (schema.notEqual != null && value === schema.notEqual) {
		return this.makeError("numberNotEqual", schema.notEqual);
	}	

	// Check integer
	if (schema.integer === true && value % 1 !== 0) {
		return this.makeError("numberInteger", value);
	}	

	// Check positive
	if (schema.positive === true && value <= 0) {
		return this.makeError("numberPositive", value);
	}	

	// Check negative
	if (schema.negative === true && value >= 0) {
		return this.makeError("numberNegative", value);
	}

	return true;
};

"use strict";

var object = function checkObject(value) {
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		return this.makeError("object");
	}

	return true;
};

"use strict";

var string = function checkString(value, schema) {
	if (typeof value !== "string") {
		return this.makeError("string");
	}

	/* TODO: charset
	 	alpha: /^[a-zA-Z]+$/
		alphaNum: /^[a-zA-Z0-9]+$/
		alphaDash: /^[a-zA-Z0-9_\-]+$/

	*/

	var valueLength = value.length;

	if (schema.empty === false && valueLength === 0) {
		return this.makeError("stringEmpty");
	}

	if (schema.min != null && valueLength < schema.min) {
		return this.makeError("stringMin", schema.min, valueLength);
	}

	if (schema.max != null && valueLength > schema.max) {
		return this.makeError("stringMax", schema.max, valueLength);
	}

	if (schema.length != null && valueLength !== schema.length) {
		return this.makeError("stringLength", schema.length, valueLength);
	}	

	if (schema.pattern != null && !schema.pattern.test(value)) {
		return this.makeError("stringPattern", schema.pattern );
	}

	if (schema.contains != null && value.indexOf(schema.contains) === -1) {
		return this.makeError("stringContains", schema.contains);
	}	

	if (schema.enum != null && schema.enum.indexOf(value) === -1) {
		return this.makeError("stringEnum", schema.enum);
	}

	return true;
};

"use strict";

var PATTERN = /^https?:\/\/\S+/;
//const PATTERN = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i;
//const PATTERN = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g;

var url = function checkUrl(value) {
	if (typeof value !== "string") {
		return this.makeError("string");
	}
	
	if (!PATTERN.test(value)) {
		return this.makeError("url");
	}

	return true;
};

"use strict";





function loadRules() {
	return {
		any: any,
		array: array,
		boolean: boolean_1,
		custom: custom,
		date: date,
		email: email,
		forbidden: forbidden,
		function: _function,
		number: number,
		object: object,
		string: string,
		url: url
	};
}

/**
 * Validator class constructor
 * 
 * @param {Object} opts 
 */
function Validator(opts) {
	this.opts = {
		messages: messages
	};

	if (opts)
		{ deepExtend_1(this.opts, opts); }

	this.messages = this.opts.messages;

	// Load rules
	this.rules = loadRules();
}

/**
 * Validate an object by schema
 * 
 * @param {Object} obj 
 * @param {Object} schema 
 */
Validator.prototype.validate = function(obj, schema) {
	var check = this.compile(schema);
	return check(obj);
};

/**
 * Compile a schema
 * 
 * @param {Object} schema 
 */
Validator.prototype.compile = function(schema) {
	var this$1 = this;

	var self = this;
	var rules;

	if (Array.isArray(schema)) {
		// Multiple schemas
		if (schema.length == 0) 
			{ throw new Error("If the schema is an Array, must contain at least one element!"); }

		return this._checkWrapper(flatten_1(schema.map(function (r) { return this$1._processRule(r, null, false); })), true);

	} else if (schema != null && typeof schema === "object") {
		rules = flatten_1(Object.keys(schema).map(function (name) { return self._processRule(schema[name], name, false); }));
	} else
		{ throw new Error("Invalid schema!"); }


	return this._checkWrapper(rules);
};

/**
 * Process a rule item & return checker functions
 * 
 * @param {Object} rule
 * @param {String} name
 * @param {Boolean} iterate
 */
Validator.prototype._processRule = function(rule, name, iterate) {
	var checks = [];

	if (typeof rule === "string") {
		rule = {
			type: rule
		};
	}

	if (Array.isArray(rule)) {
		// Compile the multiple schemas
		checks.push({
			fn: this.compile(rule),
			type: "_multi",
			name: name,
			schema: rule,
			iterate: iterate
		});

		return checks;
	}

	if (this.rules[rule.type]) {
		checks.push({
			fn: this.rules[rule.type],
			type: rule.type,
			name: name,
			schema: rule,
			iterate: iterate
		});
	} else 
		{ throw new Error("Invalid '" + rule.type + "' type in validator schema!"); }

	// Nested schema
	if (rule.type === "object" && rule.props) {
		// Compile the child schema
		checks.push({
			fn: this.compile(rule.props),
			type: rule.type,
			name: name,
			schema: rule,
			iterate: iterate
		});
	}

	// Array schema
	if (rule.type === "array" && rule.items) {
		// Compile the array schema
		checks.push({
			fn: this._checkWrapper(this._processRule(rule.items, null, false)),
			type: rule.type,
			name: name,
			schema: rule,
			iterate: true
		});
	}

	return checks;
};

/**
 * Create a wrapper function for compiled schema.
 * 
 * @param {Array} rules
 * @param {Boolean} isMultipleRules
 */
Validator.prototype._checkWrapper = function(rules, isMultipleRules) {
	var self = this;

	// Compiled validator function
	return function(obj, _schema, pathStack) {
		var errors = [];
		var count = rules.length;
		for (var i = 0; i < count; i++) {
			var check = rules[i];
			var schema = check.schema;

			var value = (void 0);
			var stack = (void 0);
			if (check.name) {
				value = obj[check.name];
				stack = (pathStack ? pathStack + "." : "") + check.name;
			} else {
				value = obj;
				stack = pathStack ? pathStack : "";
			}

			// Check required fields
			if ((value === undefined || value === null) && check.type !== "forbidden") {
				if (schema.optional !== true) {
					self.handleResult(errors, stack, self.makeError("required"));
				} else 
					{ continue; }

			} else {
				// Call the checker function
				if (check.iterate) {
					var l = value.length;
					for (var i$1 = 0; i$1 < l; i$1++) {
						var _stack = stack + "[" + i$1 + "]";
						var res = check.fn.call(self, value[i$1], schema, _stack);
						if (res !== true)
							{ self.handleResult(errors, _stack, res); }
					}
				} else {
					var res$1 = check.fn.call(self, value, schema, stack);

					if (isMultipleRules) {
						if (res$1 === true) {
							// Jump out after first success and clear previous errors
							return true;
						} 
					} 

					if (res$1 !== true)
						{ self.handleResult(errors, stack, res$1); }
				}
			}
		}

		return errors.length === 0 ? true : errors;
	};
};

/**
 * Handle results from validator functions
 * 
 * @param {Array} errors 
 * @param {String} fieldPath 
 * @param {Array|Object} res 
 */
Validator.prototype.handleResult = function(errors, fieldPath, res) {
	var this$1 = this;

	var items;
	if (!Array.isArray(res))
		{ items = [res]; }
	else
		{ items = res; }

	items.forEach(function (err) {
		if (!err.field)
			{ err.field = fieldPath; }
		if (!err.message)
			{ err.message = this$1.resolveMessage(err); }

		errors.push(err);
	});
};

/**
 * Create a validation error object
 * 
 * @param {String} type 
 * @param {Any} expected
 * @param {Any} actual
 */
Validator.prototype.makeError = function(type, expected, actual) {
	return {
		type: type,
		expected: expected,
		actual: actual
	};
};

/**
 * Resolve message string from a validation error object
 * 
 * @param {Object} err Validation error object
 */
Validator.prototype.resolveMessage = function(err) {
	var msg = this.messages[err.type];
	if (msg != null) {
		var expected = err.expected != null ? err.expected : "";
		var actual = err.actual != null ? err.actual : "";
		return msg.replace(/\{field\}/g, err.field).replace(/\{expected\}/g, expected).replace(/\{actual\}/g, actual);
	}
};

/**
 * Add a custom validator rule
 * 
 * @param {String} type
 * @param {Function} fn 
 */
Validator.prototype.add = function(type, fn) {
	this.rules[type] = fn;
};

var validator = Validator;

var fastestValidator = validator;

return fastestValidator;

})));
//# sourceMappingURL=index.js.map
